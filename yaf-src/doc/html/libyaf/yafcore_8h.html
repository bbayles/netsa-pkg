<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YAF: yafcore.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Tutorials</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_615759f7aa2b23f9d732a2fd184cb668.html">yaf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">yafcore.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;yaf/autoinc.h&gt;</code><br />
<code>#include &lt;fixbuf/public.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
</div>
<p><a href="yafcore_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyf_flow_key__st.html">yfFlowKey_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF flow key.  <a href="structyf_flow_key__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyf_flow_stats__st.html">yfFlowStats_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">yaf flow statistics  <a href="structyf_flow_stats__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyf_flow_val__st.html">yfFlowVal_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF uniflow value.  <a href="structyf_flow_val__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyf_m_p_t_c_p_flow__st.html">yfMPTCPFlow_st</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyf_flow__st.html">yfFlow_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF flow.  <a href="structyf_flow__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4e870a7230abc740fa814dda775d8c6e"><td class="memItemLeft" align="right" valign="top"><a id="a4e870a7230abc740fa814dda775d8c6e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CERT_PEN</b>&#160;&#160;&#160;6871</td></tr>
<tr class="memdesc:a4e870a7230abc740fa814dda775d8c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the CERT Private Enterprise Number (PEN) assigned by IANA, used to define our enterprise data elements to extend IPFIX RFC 5103 data model. <br /></td></tr>
<tr class="separator:a4e870a7230abc740fa814dda775d8c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bf8a39a94f6927eccf237b681308d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a90bf8a39a94f6927eccf237b681308d7">YAF_ERROR_DOMAIN</a>&#160;&#160;&#160;(g_quark_from_string(&quot;certYAFError&quot;))</td></tr>
<tr class="memdesc:a90bf8a39a94f6927eccf237b681308d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">GError domain for YAF errors.  <a href="yafcore_8h.html#a90bf8a39a94f6927eccf237b681308d7">More...</a><br /></td></tr>
<tr class="separator:a90bf8a39a94f6927eccf237b681308d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5a2f530d778e1f7f1f4973a278a2f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#aca5a2f530d778e1f7f1f4973a278a2f6">YAF_ERROR_HEADER</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:aca5a2f530d778e1f7f1f4973a278a2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF file header was malformed.  <a href="yafcore_8h.html#aca5a2f530d778e1f7f1f4973a278a2f6">More...</a><br /></td></tr>
<tr class="separator:aca5a2f530d778e1f7f1f4973a278a2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6282c576b6fc85c037ec4ea6944f8c58"><td class="memItemLeft" align="right" valign="top"><a id="a6282c576b6fc85c037ec4ea6944f8c58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_ARGUMENT</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a6282c576b6fc85c037ec4ea6944f8c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Illegal argument error. <br /></td></tr>
<tr class="separator:a6282c576b6fc85c037ec4ea6944f8c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676a9aa996fbb642eabbe13196f1dd91"><td class="memItemLeft" align="right" valign="top"><a id="a676a9aa996fbb642eabbe13196f1dd91"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_IO</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a676a9aa996fbb642eabbe13196f1dd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">General I/O error. <br /></td></tr>
<tr class="separator:a676a9aa996fbb642eabbe13196f1dd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671b4e1cc3bca4f38a5d55cbec210528"><td class="memItemLeft" align="right" valign="top"><a id="a671b4e1cc3bca4f38a5d55cbec210528"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_IPFIX</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a671b4e1cc3bca4f38a5d55cbec210528"><td class="mdescLeft">&#160;</td><td class="mdescRight">YAF could not accept IPFIX input due to missing fields. <br /></td></tr>
<tr class="separator:a671b4e1cc3bca4f38a5d55cbec210528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc8dc3f90ea1cdd17e7d9087f0a9193"><td class="memItemLeft" align="right" valign="top"><a id="adbc8dc3f90ea1cdd17e7d9087f0a9193"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_IMPL</b>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:adbc8dc3f90ea1cdd17e7d9087f0a9193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requested feature is not available. <br /></td></tr>
<tr class="separator:adbc8dc3f90ea1cdd17e7d9087f0a9193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e744837dbf0dafb0b3a81a482c4b4b"><td class="memItemLeft" align="right" valign="top"><a id="a73e744837dbf0dafb0b3a81a482c4b4b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_INTERNAL</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a73e744837dbf0dafb0b3a81a482c4b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal error occured (aka a bug) <br /></td></tr>
<tr class="separator:a73e744837dbf0dafb0b3a81a482c4b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d90d371e4eadbd2372964d75db45553"><td class="memItemLeft" align="right" valign="top"><a id="a9d90d371e4eadbd2372964d75db45553"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_LIMIT</b>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:a9d90d371e4eadbd2372964d75db45553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard program limit reached. <br /></td></tr>
<tr class="separator:a9d90d371e4eadbd2372964d75db45553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518d378ce28866a23bbeb14b247f3441"><td class="memItemLeft" align="right" valign="top"><a id="a518d378ce28866a23bbeb14b247f3441"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_EOF</b>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a518d378ce28866a23bbeb14b247f3441"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of file. <br /></td></tr>
<tr class="separator:a518d378ce28866a23bbeb14b247f3441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2225e5d104fbced4de6fdf219f1d795b"><td class="memItemLeft" align="right" valign="top"><a id="a2225e5d104fbced4de6fdf219f1d795b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_ALIGNMENT</b>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a2225e5d104fbced4de6fdf219f1d795b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal alignment error. <br /></td></tr>
<tr class="separator:a2225e5d104fbced4de6fdf219f1d795b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f63276eb8f1e2e1ebfd2dd20cf2abb"><td class="memItemLeft" align="right" valign="top"><a id="ae9f63276eb8f1e2e1ebfd2dd20cf2abb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ERROR_PACKET_PAYLOAD</b>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ae9f63276eb8f1e2e1ebfd2dd20cf2abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet payload processing error. <br /></td></tr>
<tr class="separator:ae9f63276eb8f1e2e1ebfd2dd20cf2abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748ec2ae26f407ac851800cdd787a552"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a748ec2ae26f407ac851800cdd787a552">YAF_FLOW_ACTIVE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a748ec2ae26f407ac851800cdd787a552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo end reason for flows still active during collection.  <a href="yafcore_8h.html#a748ec2ae26f407ac851800cdd787a552">More...</a><br /></td></tr>
<tr class="separator:a748ec2ae26f407ac851800cdd787a552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1f8e4daf657da7126bd7986182ec25"><td class="memItemLeft" align="right" valign="top"><a id="a2e1f8e4daf657da7126bd7986182ec25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_IDLE</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a2e1f8e4daf657da7126bd7986182ec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow ended due to idle timeout. <br /></td></tr>
<tr class="separator:a2e1f8e4daf657da7126bd7986182ec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7594540d5d2cdf742926790b59d18b1a"><td class="memItemLeft" align="right" valign="top"><a id="a7594540d5d2cdf742926790b59d18b1a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_ACTIVE</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a7594540d5d2cdf742926790b59d18b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow ended due to active timeout. <br /></td></tr>
<tr class="separator:a7594540d5d2cdf742926790b59d18b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a00d70c7f0428edc3d7b1052cc1874c"><td class="memItemLeft" align="right" valign="top"><a id="a8a00d70c7f0428edc3d7b1052cc1874c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_CLOSED</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a8a00d70c7f0428edc3d7b1052cc1874c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow ended due to FIN or RST close. <br /></td></tr>
<tr class="separator:a8a00d70c7f0428edc3d7b1052cc1874c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3ad71ab8c519b50a668b5355d1fa49"><td class="memItemLeft" align="right" valign="top"><a id="adc3ad71ab8c519b50a668b5355d1fa49"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_FORCED</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:adc3ad71ab8c519b50a668b5355d1fa49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow ended due to YAF shutdown. <br /></td></tr>
<tr class="separator:adc3ad71ab8c519b50a668b5355d1fa49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd7519c1766797ccb4a4de0db11860b"><td class="memItemLeft" align="right" valign="top"><a id="a7dd7519c1766797ccb4a4de0db11860b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_RESOURCE</b>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a7dd7519c1766797ccb4a4de0db11860b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow flushed due to YAF resource exhaustion. <br /></td></tr>
<tr class="separator:a7dd7519c1766797ccb4a4de0db11860b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416127276f04d95e28b15f018ae9196d"><td class="memItemLeft" align="right" valign="top"><a id="a416127276f04d95e28b15f018ae9196d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_UDPFORCE</b>&#160;&#160;&#160;0x1F</td></tr>
<tr class="memdesc:a416127276f04d95e28b15f018ae9196d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow flushed due to udp-uniflow on all or selected ports. <br /></td></tr>
<tr class="separator:a416127276f04d95e28b15f018ae9196d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af797d04660c7f352b5c6fe8faf325fe6"><td class="memItemLeft" align="right" valign="top"><a id="af797d04660c7f352b5c6fe8faf325fe6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_SAME_SIZE</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:af797d04660c7f352b5c6fe8faf325fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow has same size packets in this direction. <br /></td></tr>
<tr class="separator:af797d04660c7f352b5c6fe8faf325fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0924e9fd97124c7f992e8bda2ac3df0"><td class="memItemLeft" align="right" valign="top"><a id="ad0924e9fd97124c7f992e8bda2ac3df0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_OUT_OF_SEQUENCE</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ad0924e9fd97124c7f992e8bda2ac3df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow was processed out of sequence. <br /></td></tr>
<tr class="separator:ad0924e9fd97124c7f992e8bda2ac3df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d1729bca8e7d4651160e3579e67c5b"><td class="memItemLeft" align="right" valign="top"><a id="ab2d1729bca8e7d4651160e3579e67c5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_MP_CAPABLE</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:ab2d1729bca8e7d4651160e3579e67c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow had MP_CAPABLE TCP Option. <br /></td></tr>
<tr class="separator:ab2d1729bca8e7d4651160e3579e67c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2851172808f819b461721c4952a5de"><td class="memItemLeft" align="right" valign="top"><a id="a0d2851172808f819b461721c4952a5de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_FRAGMENTS</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:a0d2851172808f819b461721c4952a5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow contained packets that were fragmented. <br /></td></tr>
<tr class="separator:a0d2851172808f819b461721c4952a5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219601cfc9f6ab1c38648afafbb596c9"><td class="memItemLeft" align="right" valign="top"><a id="a219601cfc9f6ab1c38648afafbb596c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_PARTIAL_FRAGS</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:a219601cfc9f6ab1c38648afafbb596c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow contains partial fragments. <br /></td></tr>
<tr class="separator:a219601cfc9f6ab1c38648afafbb596c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741d946a09ea41f01d32f1bb770d0003"><td class="memItemLeft" align="right" valign="top"><a id="a741d946a09ea41f01d32f1bb770d0003"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_FRAG_ACTIVE</b>&#160;&#160;&#160;0x03</td></tr>
<tr class="memdesc:a741d946a09ea41f01d32f1bb770d0003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow has fragments that have reached active timeout. <br /></td></tr>
<tr class="separator:a741d946a09ea41f01d32f1bb770d0003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4305f7e14741c460ec98b000e6d96815"><td class="memItemLeft" align="right" valign="top"><a id="a4305f7e14741c460ec98b000e6d96815"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_FRAG_PASSIVE</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:a4305f7e14741c460ec98b000e6d96815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow has fragments that have reached passive timeout. <br /></td></tr>
<tr class="separator:a4305f7e14741c460ec98b000e6d96815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a3726fe7960f4bea91466c930904ea"><td class="memItemLeft" align="right" valign="top"><a id="ab0a3726fe7960f4bea91466c930904ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_END_MASK</b>&#160;&#160;&#160;0x7F</td></tr>
<tr class="memdesc:ab0a3726fe7960f4bea91466c930904ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow reason mask. <br /></td></tr>
<tr class="separator:ab0a3726fe7960f4bea91466c930904ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae912d9a7f9cf3ff896f5ba9e849f1e66"><td class="memItemLeft" align="right" valign="top"><a id="ae912d9a7f9cf3ff896f5ba9e849f1e66"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_ENDF_ISCONT</b>&#160;&#160;&#160;0x80</td></tr>
<tr class="memdesc:ae912d9a7f9cf3ff896f5ba9e849f1e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">SiLK mode flow reason flag - flow was created after active termination. <br /></td></tr>
<tr class="separator:ae912d9a7f9cf3ff896f5ba9e849f1e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb7c588d476dd7dacff04b6f2b87fd8"><td class="memItemLeft" align="right" valign="top"><a id="a1fb7c588d476dd7dacff04b6f2b87fd8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_IP_ICMP</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a1fb7c588d476dd7dacff04b6f2b87fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP protocol identifier for ICMP. <br /></td></tr>
<tr class="separator:a1fb7c588d476dd7dacff04b6f2b87fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddac667f4893f825b2c36f439cf2d25"><td class="memItemLeft" align="right" valign="top"><a id="a6ddac667f4893f825b2c36f439cf2d25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_IP_TCP</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a6ddac667f4893f825b2c36f439cf2d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP protocol identifier for TCP. <br /></td></tr>
<tr class="separator:a6ddac667f4893f825b2c36f439cf2d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfb66639fbd610af657911ed5de5a06"><td class="memItemLeft" align="right" valign="top"><a id="a1bfb66639fbd610af657911ed5de5a06"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_IP_UDP</b>&#160;&#160;&#160;17</td></tr>
<tr class="memdesc:a1bfb66639fbd610af657911ed5de5a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP protocol identifier for UDP. <br /></td></tr>
<tr class="separator:a1bfb66639fbd610af657911ed5de5a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c00594ac34eb99ead87136ff390093"><td class="memItemLeft" align="right" valign="top"><a id="a44c00594ac34eb99ead87136ff390093"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YFP_IPTCPHEADER_SIZE</b>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:a44c00594ac34eb99ead87136ff390093"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the size of the packet to store away for use primarily in passive OS fingerprinting, this value is only used if application labeling is enabled. <br /></td></tr>
<tr class="separator:a44c00594ac34eb99ead87136ff390093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcda5832463d24a4f46a5e646121892"><td class="memItemLeft" align="right" valign="top"><a id="a9dcda5832463d24a4f46a5e646121892"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ETHERNET_MAC_ADDR_LENGTH</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a9dcda5832463d24a4f46a5e646121892"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of Ethernet MAC Address <br /></td></tr>
<tr class="separator:a9dcda5832463d24a4f46a5e646121892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2395ccdd70f26be0ecef94cca543efda"><td class="memItemLeft" align="right" valign="top"><a id="a2395ccdd70f26be0ecef94cca543efda"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_MAX_HOOKS</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a2395ccdd70f26be0ecef94cca543efda"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of hooks (plugins) allowed at one time <br /></td></tr>
<tr class="separator:a2395ccdd70f26be0ecef94cca543efda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02f9275b48945fbb8ef55058be71f6c"><td class="memItemLeft" align="right" valign="top"><a id="aa02f9275b48945fbb8ef55058be71f6c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_HOOKS_MAX_EXPORT</b>&#160;&#160;&#160;1500</td></tr>
<tr class="memdesc:aa02f9275b48945fbb8ef55058be71f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is the maximum amount of data that the plugins may export in sum total <br /></td></tr>
<tr class="separator:aa02f9275b48945fbb8ef55058be71f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a096b81cc71a4436967322b1dea4994"><td class="memItemLeft" align="right" valign="top"><a id="a9a096b81cc71a4436967322b1dea4994"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_MAX_PKT_BOUNDARY</b>&#160;&#160;&#160;25</td></tr>
<tr class="memdesc:a9a096b81cc71a4436967322b1dea4994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum Number of Packet Boundaries to keep around per payload. <br /></td></tr>
<tr class="separator:a9a096b81cc71a4436967322b1dea4994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d6a419db9b3f4d638d664a5c897691"><td class="memItemLeft" align="right" valign="top"><a id="a93d6a419db9b3f4d638d664a5c897691"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_PCAP_MAX</b>&#160;&#160;&#160;5000000</td></tr>
<tr class="memdesc:a93d6a419db9b3f4d638d664a5c897691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of PCAP output file - 5MB. <br /></td></tr>
<tr class="separator:a93d6a419db9b3f4d638d664a5c897691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc0f654dac7b347d8a50b446397faf7"><td class="memItemLeft" align="right" valign="top"><a id="a0dc0f654dac7b347d8a50b446397faf7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>YAF_MAX_MPLS_LABELS</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a0dc0f654dac7b347d8a50b446397faf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of labels we're going to keep around. <br /></td></tr>
<tr class="separator:a0dc0f654dac7b347d8a50b446397faf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1ac4b4f6b2720c2af3c728aec9abd7a2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structyf_flow_key__st.html">yfFlowKey_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a1ac4b4f6b2720c2af3c728aec9abd7a2">yfFlowKey_t</a></td></tr>
<tr class="memdesc:a1ac4b4f6b2720c2af3c728aec9abd7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF flow key.  <a href="yafcore_8h.html#a1ac4b4f6b2720c2af3c728aec9abd7a2">More...</a><br /></td></tr>
<tr class="separator:a1ac4b4f6b2720c2af3c728aec9abd7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d57343f0a558146a78d44e621bb5fa"><td class="memItemLeft" align="right" valign="top"><a id="ae3d57343f0a558146a78d44e621bb5fa"></a>
typedef struct <a class="el" href="structyf_flow_stats__st.html">yfFlowStats_st</a>&#160;</td><td class="memItemRight" valign="bottom"><b>yfFlowStats_t</b></td></tr>
<tr class="memdesc:ae3d57343f0a558146a78d44e621bb5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">yaf flow statistics <br /></td></tr>
<tr class="separator:ae3d57343f0a558146a78d44e621bb5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c408b16b38eab11ab595368798ac304"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structyf_flow_val__st.html">yfFlowVal_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a9c408b16b38eab11ab595368798ac304">yfFlowVal_t</a></td></tr>
<tr class="memdesc:a9c408b16b38eab11ab595368798ac304"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF uniflow value.  <a href="yafcore_8h.html#a9c408b16b38eab11ab595368798ac304">More...</a><br /></td></tr>
<tr class="separator:a9c408b16b38eab11ab595368798ac304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ddd5f567938d05714b661fa69b7095"><td class="memItemLeft" align="right" valign="top"><a id="a08ddd5f567938d05714b661fa69b7095"></a>
typedef struct <a class="el" href="structyf_m_p_t_c_p_flow__st.html">yfMPTCPFlow_st</a>&#160;</td><td class="memItemRight" valign="bottom"><b>yfMPTCPFlow_t</b></td></tr>
<tr class="separator:a08ddd5f567938d05714b661fa69b7095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac846c7e494485aceab2fcdec4264f90f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structyf_flow__st.html">yfFlow_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a></td></tr>
<tr class="memdesc:ac846c7e494485aceab2fcdec4264f90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A YAF flow.  <a href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">More...</a><br /></td></tr>
<tr class="separator:ac846c7e494485aceab2fcdec4264f90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a68a8f1cdca0c20efb8bce1dd0e6917c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a68a8f1cdca0c20efb8bce1dd0e6917c1">yfAlignmentCheck</a> (void)</td></tr>
<tr class="memdesc:a68a8f1cdca0c20efb8bce1dd0e6917c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">yfAlignmentCheck  <a href="yafcore_8h.html#a68a8f1cdca0c20efb8bce1dd0e6917c1">More...</a><br /></td></tr>
<tr class="separator:a68a8f1cdca0c20efb8bce1dd0e6917c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a23294d877e529cacc564bb3a51488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a96a23294d877e529cacc564bb3a51488">yfFlowPrepare</a> (<a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow)</td></tr>
<tr class="memdesc:a96a23294d877e529cacc564bb3a51488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a static flow buffer for use with yaf_flow_read().  <a href="yafcore_8h.html#a96a23294d877e529cacc564bb3a51488">More...</a><br /></td></tr>
<tr class="separator:a96a23294d877e529cacc564bb3a51488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771c185221c27f7b69374c40b208a0e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a771c185221c27f7b69374c40b208a0e3">yfFlowCleanup</a> (<a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow)</td></tr>
<tr class="memdesc:a771c185221c27f7b69374c40b208a0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after a static flow buffer prepared by yfFlowPrepare.  <a href="yafcore_8h.html#a771c185221c27f7b69374c40b208a0e3">More...</a><br /></td></tr>
<tr class="separator:a771c185221c27f7b69374c40b208a0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fd21827aba3e5a6ffc76d03c28e97e"><td class="memItemLeft" align="right" valign="top">fBuf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a80fd21827aba3e5a6ffc76d03c28e97e">yfWriterForFile</a> (const char *path, uint32_t domain, gboolean export_meta, GError **err)</td></tr>
<tr class="memdesc:a80fd21827aba3e5a6ffc76d03c28e97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IPFIX message buffer for writing YAF flows to a named file.  <a href="yafcore_8h.html#a80fd21827aba3e5a6ffc76d03c28e97e">More...</a><br /></td></tr>
<tr class="separator:a80fd21827aba3e5a6ffc76d03c28e97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3670cb9472bebff1a4c14aafc8edfae5"><td class="memItemLeft" align="right" valign="top">fBuf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a3670cb9472bebff1a4c14aafc8edfae5">yfWriterForFP</a> (FILE *fp, uint32_t domain, gboolean export_meta, GError **err)</td></tr>
<tr class="memdesc:a3670cb9472bebff1a4c14aafc8edfae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IPFIX message buffer for writing YAF flows to an open file pointer.  <a href="yafcore_8h.html#a3670cb9472bebff1a4c14aafc8edfae5">More...</a><br /></td></tr>
<tr class="separator:a3670cb9472bebff1a4c14aafc8edfae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afc51621f94454beffc7862136ebc73"><td class="memItemLeft" align="right" valign="top">fBuf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a2afc51621f94454beffc7862136ebc73">yfWriterForSpec</a> (fbConnSpec_t *spec, uint32_t domain, gboolean export_meta, GError **err)</td></tr>
<tr class="memdesc:a2afc51621f94454beffc7862136ebc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IPFIX message buffer for writing YAF flows to a socket.  <a href="yafcore_8h.html#a2afc51621f94454beffc7862136ebc73">More...</a><br /></td></tr>
<tr class="separator:a2afc51621f94454beffc7862136ebc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107643892b9846c39b27ecea4b90cf35"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a107643892b9846c39b27ecea4b90cf35">yfWriteOptionsDataFlows</a> (void *yfContext, uint32_t pcap_drop, GTimer *timer, GError **err)</td></tr>
<tr class="memdesc:a107643892b9846c39b27ecea4b90cf35"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper that calls both yfWriteStatsFlow and yfWriteDataFlow with appropriate condition checking.  <a href="yafcore_8h.html#a107643892b9846c39b27ecea4b90cf35">More...</a><br /></td></tr>
<tr class="separator:a107643892b9846c39b27ecea4b90cf35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad688e7ab8e1c8a7c221db81b8b4ab9b"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#aad688e7ab8e1c8a7c221db81b8b4ab9b">yfWriteStatsFlow</a> (void *yfContext, uint32_t pcap_drop, GTimer *timer, GError **err)</td></tr>
<tr class="memdesc:aad688e7ab8e1c8a7c221db81b8b4ab9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a statistics options data record to an IPFIX Message buffer.  <a href="yafcore_8h.html#aad688e7ab8e1c8a7c221db81b8b4ab9b">More...</a><br /></td></tr>
<tr class="separator:aad688e7ab8e1c8a7c221db81b8b4ab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791a57ef2c8c5e66afa9ca3b9ceaa298"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a791a57ef2c8c5e66afa9ca3b9ceaa298">yfWriteTombstoneFlow</a> (void *yfContext, GError **err)</td></tr>
<tr class="memdesc:a791a57ef2c8c5e66afa9ca3b9ceaa298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a tombstone options data record to an IPFIX Message buffer.  <a href="yafcore_8h.html#a791a57ef2c8c5e66afa9ca3b9ceaa298">More...</a><br /></td></tr>
<tr class="separator:a791a57ef2c8c5e66afa9ca3b9ceaa298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aba445d9e6561395ee1a2de5a91ac15"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a4aba445d9e6561395ee1a2de5a91ac15">yfWriteFlow</a> (void *yfContext, <a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, GError **err)</td></tr>
<tr class="memdesc:a4aba445d9e6561395ee1a2de5a91ac15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single flow to an IPFIX message buffer.  <a href="yafcore_8h.html#a4aba445d9e6561395ee1a2de5a91ac15">More...</a><br /></td></tr>
<tr class="separator:a4aba445d9e6561395ee1a2de5a91ac15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9d2497ad9dfacc3abb8cc20a95492b"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#ace9d2497ad9dfacc3abb8cc20a95492b">yfWriterClose</a> (fBuf_t *fbuf, gboolean flush, GError **err)</td></tr>
<tr class="memdesc:ace9d2497ad9dfacc3abb8cc20a95492b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the connection underlying an IPFIX message buffer created by <a class="el" href="yafcore_8h.html#a3670cb9472bebff1a4c14aafc8edfae5" title="Get an IPFIX message buffer for writing YAF flows to an open file pointer.">yfWriterForFP()</a> or <a class="el" href="yafcore_8h.html#a2afc51621f94454beffc7862136ebc73" title="Get an IPFIX message buffer for writing YAF flows to a socket.">yfWriterForSpec()</a>.  <a href="yafcore_8h.html#ace9d2497ad9dfacc3abb8cc20a95492b">More...</a><br /></td></tr>
<tr class="separator:ace9d2497ad9dfacc3abb8cc20a95492b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cb87d59c756b4b5185eec7b10518e0"><td class="memItemLeft" align="right" valign="top"><a id="a15cb87d59c756b4b5185eec7b10518e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>yfWriterExportPayload</b> (int max_payload)</td></tr>
<tr class="memdesc:a15cb87d59c756b4b5185eec7b10518e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIXME doc. <br /></td></tr>
<tr class="separator:a15cb87d59c756b4b5185eec7b10518e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf608a94a2469d3b6777c3b92aa9937e"><td class="memItemLeft" align="right" valign="top"><a id="acf608a94a2469d3b6777c3b92aa9937e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>yfWriterExportMappedV6</b> (gboolean map_mode)</td></tr>
<tr class="memdesc:acf608a94a2469d3b6777c3b92aa9937e"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIXME doc. <br /></td></tr>
<tr class="separator:acf608a94a2469d3b6777c3b92aa9937e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16f93ae5f4e71b3a5928feb2ca5e32e"><td class="memItemLeft" align="right" valign="top">fBuf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#ab16f93ae5f4e71b3a5928feb2ca5e32e">yfReaderForFP</a> (fBuf_t *fbuf, FILE *fp, GError **err)</td></tr>
<tr class="memdesc:ab16f93ae5f4e71b3a5928feb2ca5e32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IPFIX message buffer for reading YAF flows from an open file pointer.  <a href="yafcore_8h.html#ab16f93ae5f4e71b3a5928feb2ca5e32e">More...</a><br /></td></tr>
<tr class="separator:ab16f93ae5f4e71b3a5928feb2ca5e32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aa6a5b106786904819cce86b0c736d"><td class="memItemLeft" align="right" valign="top">fbListener_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#ae1aa6a5b106786904819cce86b0c736d">yfListenerForSpec</a> (fbConnSpec_t *spec, fbListenerAppInit_fn appinit, fbListenerAppFree_fn appfree, GError **err)</td></tr>
<tr class="memdesc:ae1aa6a5b106786904819cce86b0c736d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IPFIX connection listener for collecting YAF flows via IPFIX from the network.  <a href="yafcore_8h.html#ae1aa6a5b106786904819cce86b0c736d">More...</a><br /></td></tr>
<tr class="separator:ae1aa6a5b106786904819cce86b0c736d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4916880e1835ed3bc8d2912791076caf"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a4916880e1835ed3bc8d2912791076caf">yfReadFlow</a> (fBuf_t *fbuf, <a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, GError **err)</td></tr>
<tr class="memdesc:a4916880e1835ed3bc8d2912791076caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single flow from an IPFIX message buffer.  <a href="yafcore_8h.html#a4916880e1835ed3bc8d2912791076caf">More...</a><br /></td></tr>
<tr class="separator:a4916880e1835ed3bc8d2912791076caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2508ff2b0d463c2689e382e4b46bc167"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a2508ff2b0d463c2689e382e4b46bc167">yfReadFlowExtended</a> (fBuf_t *fbuf, <a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, GError **err)</td></tr>
<tr class="memdesc:a2508ff2b0d463c2689e382e4b46bc167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single flow from an IPFIX message buffer.  <a href="yafcore_8h.html#a2508ff2b0d463c2689e382e4b46bc167">More...</a><br /></td></tr>
<tr class="separator:a2508ff2b0d463c2689e382e4b46bc167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65663f982cb1eec1717c9608584c2ff0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a65663f982cb1eec1717c9608584c2ff0">yfPrintString</a> (GString *rstr, <a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow)</td></tr>
<tr class="memdesc:a65663f982cb1eec1717c9608584c2ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a YAF flow to a GString.  <a href="yafcore_8h.html#a65663f982cb1eec1717c9608584c2ff0">More...</a><br /></td></tr>
<tr class="separator:a65663f982cb1eec1717c9608584c2ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7320f2e7a349df396c09ebfccbb9311a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a7320f2e7a349df396c09ebfccbb9311a">yfPrintDelimitedString</a> (GString *rstr, <a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, gboolean yaft_mac)</td></tr>
<tr class="memdesc:a7320f2e7a349df396c09ebfccbb9311a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a YAF flow to a GString in pipe-delimited (tabular) format.  <a href="yafcore_8h.html#a7320f2e7a349df396c09ebfccbb9311a">More...</a><br /></td></tr>
<tr class="separator:a7320f2e7a349df396c09ebfccbb9311a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84556dc608d472f7efa5c7a22a1ed714"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#a84556dc608d472f7efa5c7a22a1ed714">yfPrint</a> (FILE *out, <a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, GError **err)</td></tr>
<tr class="memdesc:a84556dc608d472f7efa5c7a22a1ed714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a YAF flow to a file.  <a href="yafcore_8h.html#a84556dc608d472f7efa5c7a22a1ed714">More...</a><br /></td></tr>
<tr class="separator:a84556dc608d472f7efa5c7a22a1ed714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67f74d1debf3a8af50537cfa714fd2b"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#ac67f74d1debf3a8af50537cfa714fd2b">yfPrintDelimited</a> (FILE *out, <a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *flow, gboolean yaft_mac, GError **err)</td></tr>
<tr class="memdesc:ac67f74d1debf3a8af50537cfa714fd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a YAF flow to a file in pipe-delimited (tabular) format.  <a href="yafcore_8h.html#ac67f74d1debf3a8af50537cfa714fd2b">More...</a><br /></td></tr>
<tr class="separator:ac67f74d1debf3a8af50537cfa714fd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e6ac6049bf5feb7c9d4c2430a4ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="yafcore_8h.html#ad77e6ac6049bf5feb7c9d4c2430a4ce1">yfPrintColumnHeaders</a> (FILE *out, gboolean yaft_mac, GError **err)</td></tr>
<tr class="memdesc:ad77e6ac6049bf5feb7c9d4c2430a4ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print column headers for the pipe-delimited (tabular) format.  <a href="yafcore_8h.html#ad77e6ac6049bf5feb7c9d4c2430a4ce1">More...</a><br /></td></tr>
<tr class="separator:ad77e6ac6049bf5feb7c9d4c2430a4ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >YAF Core Library. </p>
<p >Defines API for reading and writing YAF files, and the yfFlow_t data structures. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a90bf8a39a94f6927eccf237b681308d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bf8a39a94f6927eccf237b681308d7">&#9670;&nbsp;</a></span>YAF_ERROR_DOMAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define YAF_ERROR_DOMAIN&#160;&#160;&#160;(g_quark_from_string(&quot;certYAFError&quot;))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GError domain for YAF errors. </p>
<p >All YAF errors belong to this domain. In addition, YAF core library routines can return libfixbuf errors if reading or writing fails. </p>

</div>
</div>
<a id="aca5a2f530d778e1f7f1f4973a278a2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5a2f530d778e1f7f1f4973a278a2f6">&#9670;&nbsp;</a></span>YAF_ERROR_HEADER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define YAF_ERROR_HEADER&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A YAF file header was malformed. </p>
<p >The file is probably not a YAF file. </p>

</div>
</div>
<a id="a748ec2ae26f407ac851800cdd787a552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748ec2ae26f407ac851800cdd787a552">&#9670;&nbsp;</a></span>YAF_FLOW_ACTIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define YAF_FLOW_ACTIVE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pseudo end reason for flows still active during collection. </p>
<p >Not valid on disk. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac846c7e494485aceab2fcdec4264f90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac846c7e494485aceab2fcdec4264f90f">&#9670;&nbsp;</a></span>yfFlow_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structyf_flow__st.html">yfFlow_st</a> <a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A YAF flow. </p>
<p >Joins a flow key with forward and reverse flow values in time.</p>
<dl class="section note"><dt>Note</dt><dd>if you edit the layout of this structure, you must make a corresponding edit of the yfFlowIPv4_t structure in yaftab.c </dd></dl>

</div>
</div>
<a id="a1ac4b4f6b2720c2af3c728aec9abd7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac4b4f6b2720c2af3c728aec9abd7a2">&#9670;&nbsp;</a></span>yfFlowKey_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structyf_flow_key__st.html">yfFlowKey_st</a> <a class="el" href="yafcore_8h.html#a1ac4b4f6b2720c2af3c728aec9abd7a2">yfFlowKey_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A YAF flow key. </p>
<p >Contains a flow's five-tuple; used at runtime in the flow table. </p>

</div>
</div>
<a id="a9c408b16b38eab11ab595368798ac304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c408b16b38eab11ab595368798ac304">&#9670;&nbsp;</a></span>yfFlowVal_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structyf_flow_val__st.html">yfFlowVal_st</a> <a class="el" href="yafcore_8h.html#a9c408b16b38eab11ab595368798ac304">yfFlowVal_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A YAF uniflow value. </p>
<p >Contains directional packet header fields and counters; two of these are used to build a biflow. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a68a8f1cdca0c20efb8bce1dd0e6917c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a8f1cdca0c20efb8bce1dd0e6917c1">&#9670;&nbsp;</a></span>yfAlignmentCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfAlignmentCheck </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>yfAlignmentCheck </p>
<p >This is a purely internal diagnostic function. It checks the alignment of the internal data structures that are used with fixbuf and causes the program to abort if there is an alignment issue. </p>

</div>
</div>
<a id="a771c185221c27f7b69374c40b208a0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771c185221c27f7b69374c40b208a0e3">&#9670;&nbsp;</a></span>yfFlowCleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfFlowCleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *&#160;</td>
          <td class="paramname"><em>flow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up after a static flow buffer prepared by yfFlowPrepare. </p>
<p >This is used to free storage for payload information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flow</td><td>a yfFlow_t to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96a23294d877e529cacc564bb3a51488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a23294d877e529cacc564bb3a51488">&#9670;&nbsp;</a></span>yfFlowPrepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfFlowPrepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *&#160;</td>
          <td class="paramname"><em>flow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a static flow buffer for use with yaf_flow_read(). </p>
<p >Call this before the first yaf_flow_read() call; subsequent reads do not need initialization. This is used to prepare storage for payload information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flow</td><td>a yfFlow_t to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1aa6a5b106786904819cce86b0c736d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aa6a5b106786904819cce86b0c736d">&#9670;&nbsp;</a></span>yfListenerForSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fbListener_t * yfListenerForSpec </td>
          <td>(</td>
          <td class="paramtype">fbConnSpec_t *&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fbListenerAppInit_fn&#160;</td>
          <td class="paramname"><em>appinit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fbListenerAppFree_fn&#160;</td>
          <td class="paramname"><em>appfree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an IPFIX connection listener for collecting YAF flows via IPFIX from the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>fixbuf connection specifier for local end of socket. </td></tr>
    <tr><td class="paramname">appinit</td><td>Application context initialization function, for creating application-specific collector contexts. Pass NULL for no appinit function. </td></tr>
    <tr><td class="paramname">appfree</td><td>Application context cleanup function. Pass NULL for no appfree function. </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new listener, initialized for reading YAF flows, for use with fbListenerWait(). Buffers returned from this call can then be used with <a class="el" href="yafcore_8h.html#a4916880e1835ed3bc8d2912791076caf" title="Read a single flow from an IPFIX message buffer.">yfReadFlow()</a> and <a class="el" href="yafcore_8h.html#a2508ff2b0d463c2689e382e4b46bc167" title="Read a single flow from an IPFIX message buffer.">yfReadFlowExtended()</a>. </dd></dl>

</div>
</div>
<a id="a84556dc608d472f7efa5c7a22a1ed714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84556dc608d472f7efa5c7a22a1ed714">&#9670;&nbsp;</a></span>yfPrint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfPrint </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a YAF flow to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>file to print to. </td></tr>
    <tr><td class="paramname">flow</td><td>flow to print. </td></tr>
    <tr><td class="paramname">err</td><td>an error descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ad77e6ac6049bf5feb7c9d4c2430a4ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77e6ac6049bf5feb7c9d4c2430a4ce1">&#9670;&nbsp;</a></span>yfPrintColumnHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfPrintColumnHeaders </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>yaft_mac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print column headers for the pipe-delimited (tabular) format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>file to print to. </td></tr>
    <tr><td class="paramname">yaft_mac</td><td>print mac address column headers if enabled </td></tr>
    <tr><td class="paramname">err</td><td>an error descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ac67f74d1debf3a8af50537cfa714fd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67f74d1debf3a8af50537cfa714fd2b">&#9670;&nbsp;</a></span>yfPrintDelimited()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfPrintDelimited </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>yaft_mac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a YAF flow to a file in pipe-delimited (tabular) format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>file to print to. </td></tr>
    <tr><td class="paramname">flow</td><td>flow to print. </td></tr>
    <tr><td class="paramname">yaft_mac</td><td>print mac addresses in tabular format </td></tr>
    <tr><td class="paramname">err</td><td>an error descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a7320f2e7a349df396c09ebfccbb9311a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7320f2e7a349df396c09ebfccbb9311a">&#9670;&nbsp;</a></span>yfPrintDelimitedString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfPrintDelimitedString </td>
          <td>(</td>
          <td class="paramtype">GString *&#160;</td>
          <td class="paramname"><em>rstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>yaft_mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a YAF flow to a GString in pipe-delimited (tabular) format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rstr</td><td>string to append text representation of flow to. </td></tr>
    <tr><td class="paramname">flow</td><td>flow to print. </td></tr>
    <tr><td class="paramname">yaft_mac</td><td>Add mac addresses to tabular format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65663f982cb1eec1717c9608584c2ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65663f982cb1eec1717c9608584c2ff0">&#9670;&nbsp;</a></span>yfPrintString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yfPrintString </td>
          <td>(</td>
          <td class="paramtype">GString *&#160;</td>
          <td class="paramname"><em>rstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *&#160;</td>
          <td class="paramname"><em>flow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a YAF flow to a GString. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rstr</td><td>string to append text representation of flow to. </td></tr>
    <tr><td class="paramname">flow</td><td>flow to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab16f93ae5f4e71b3a5928feb2ca5e32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16f93ae5f4e71b3a5928feb2ca5e32e">&#9670;&nbsp;</a></span>yfReaderForFP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fBuf_t * yfReaderForFP </td>
          <td>(</td>
          <td class="paramtype">fBuf_t *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an IPFIX message buffer for reading YAF flows from an open file pointer. </p>
<p >Reuses an existing buffer if supplied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>IPFIX message buffer to reuse; must have been returned by a prior call to <a class="el" href="yafcore_8h.html#ab16f93ae5f4e71b3a5928feb2ca5e32e" title="Get an IPFIX message buffer for reading YAF flows from an open file pointer.">yfReaderForFP()</a>. Pass NULL to create a new buffer. </td></tr>
    <tr><td class="paramname">fp</td><td>File pointer to open file to read from. </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new reader, or a reused reader, for reading the given open file. NULL on failure. </dd></dl>

</div>
</div>
<a id="a4916880e1835ed3bc8d2912791076caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4916880e1835ed3bc8d2912791076caf">&#9670;&nbsp;</a></span>yfReadFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfReadFlow </td>
          <td>(</td>
          <td class="paramtype">fBuf_t *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single flow from an IPFIX message buffer. </p>
<p >The buffer must have been returned by <a class="el" href="yafcore_8h.html#ab16f93ae5f4e71b3a5928feb2ca5e32e" title="Get an IPFIX message buffer for reading YAF flows from an open file pointer.">yfReaderForFP()</a>, or by fbListenerWait() called on a listener created by <a class="el" href="yafcore_8h.html#ae1aa6a5b106786904819cce86b0c736d" title="Get an IPFIX connection listener for collecting YAF flows via IPFIX from the network.">yfListenerForSpec()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>Buffer to read message from, returned by <a class="el" href="yafcore_8h.html#ab16f93ae5f4e71b3a5928feb2ca5e32e" title="Get an IPFIX message buffer for reading YAF flows from an open file pointer.">yfReaderForFP()</a> or from a YAF listener. </td></tr>
    <tr><td class="paramname">flow</td><td>pointer to yfFlow_t structure to fill from file or stream. </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. If false, check error against FB_ERROR_EOF to determine if the message reader is at end of file or stream, or against FB_ERROR_EOM to see if the listener should be waited upon. </dd></dl>

</div>
</div>
<a id="a2508ff2b0d463c2689e382e4b46bc167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2508ff2b0d463c2689e382e4b46bc167">&#9670;&nbsp;</a></span>yfReadFlowExtended()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfReadFlowExtended </td>
          <td>(</td>
          <td class="paramtype">fBuf_t *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single flow from an IPFIX message buffer. </p>
<p >The buffer must have been returned by <a class="el" href="yafcore_8h.html#ab16f93ae5f4e71b3a5928feb2ca5e32e" title="Get an IPFIX message buffer for reading YAF flows from an open file pointer.">yfReaderForFP()</a>, or by fbListenerWait() called on a listener created by <a class="el" href="yafcore_8h.html#ae1aa6a5b106786904819cce86b0c736d" title="Get an IPFIX connection listener for collecting YAF flows via IPFIX from the network.">yfListenerForSpec()</a>. This function does not necessarily require its input to have been written by <a class="el" href="yafcore_8h.html#a4aba445d9e6561395ee1a2de5a91ac15" title="Write a single flow to an IPFIX message buffer.">yfWriteFlow()</a>; it supports additional flow timestamp and counter IEs that may be exported by other IPFIX exporting processes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>Buffer to read message from, returned by <a class="el" href="yafcore_8h.html#ab16f93ae5f4e71b3a5928feb2ca5e32e" title="Get an IPFIX message buffer for reading YAF flows from an open file pointer.">yfReaderForFP()</a> or from a YAF listener. </td></tr>
    <tr><td class="paramname">flow</td><td>pointer to yfFlow_t structure to fill from file or stream. </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. If false, check error against FB_ERROR_EOF to determine if the message reader is at end of file or stream, or against FB_ERROR_EOM to see if the listener should be waited upon. </dd></dl>

</div>
</div>
<a id="a4aba445d9e6561395ee1a2de5a91ac15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aba445d9e6561395ee1a2de5a91ac15">&#9670;&nbsp;</a></span>yfWriteFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfWriteFlow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>yfContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="yafcore_8h.html#ac846c7e494485aceab2fcdec4264f90f">yfFlow_t</a> *&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single flow to an IPFIX message buffer. </p>
<p >The buffer must have been returned by <a class="el" href="yafcore_8h.html#a3670cb9472bebff1a4c14aafc8edfae5" title="Get an IPFIX message buffer for writing YAF flows to an open file pointer.">yfWriterForFP()</a> or <a class="el" href="yafcore_8h.html#a2afc51621f94454beffc7862136ebc73" title="Get an IPFIX message buffer for writing YAF flows to a socket.">yfWriterForSpec()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yfContext</td><td>Context pointer for the yaf state, used to get the fbuf pointer, a buffer to write the message to, returned from <a class="el" href="yafcore_8h.html#a3670cb9472bebff1a4c14aafc8edfae5" title="Get an IPFIX message buffer for writing YAF flows to an open file pointer.">yfWriterForFP()</a> or <a class="el" href="yafcore_8h.html#a2afc51621f94454beffc7862136ebc73" title="Get an IPFIX message buffer for writing YAF flows to a socket.">yfWriterForSpec()</a> </td></tr>
    <tr><td class="paramname">flow</td><td>pointer to yfFlow_t to write to file or stream. </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a107643892b9846c39b27ecea4b90cf35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107643892b9846c39b27ecea4b90cf35">&#9670;&nbsp;</a></span>yfWriteOptionsDataFlows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfWriteOptionsDataFlows </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>yfContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pcap_drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GTimer *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper that calls both yfWriteStatsFlow and yfWriteDataFlow with appropriate condition checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yfContext</td><td>Context pointer for the yaf state, used to get the fbuf pointer. </td></tr>
    <tr><td class="paramname">pcap_drop</td><td>Number of packets dropped reported by libpcap </td></tr>
    <tr><td class="paramname">timer</td><td>Pointer to yafstats GTimer </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ace9d2497ad9dfacc3abb8cc20a95492b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9d2497ad9dfacc3abb8cc20a95492b">&#9670;&nbsp;</a></span>yfWriterClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfWriterClose </td>
          <td>(</td>
          <td class="paramtype">fBuf_t *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the connection underlying an IPFIX message buffer created by <a class="el" href="yafcore_8h.html#a3670cb9472bebff1a4c14aafc8edfae5" title="Get an IPFIX message buffer for writing YAF flows to an open file pointer.">yfWriterForFP()</a> or <a class="el" href="yafcore_8h.html#a2afc51621f94454beffc7862136ebc73" title="Get an IPFIX message buffer for writing YAF flows to a socket.">yfWriterForSpec()</a>. </p>
<p >If flush is TRUE, forces any message in progress to be emitted before close; use FALSE if closing the buffer in response to a write error. Does not free the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>buffer to close. </td></tr>
    <tr><td class="paramname">flush</td><td>TRUE to flush buffer before closing. </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a80fd21827aba3e5a6ffc76d03c28e97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fd21827aba3e5a6ffc76d03c28e97e">&#9670;&nbsp;</a></span>yfWriterForFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fBuf_t * yfWriterForFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>export_meta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an IPFIX message buffer for writing YAF flows to a named file. </p>
<p >Sets the observation domain of the buffer to the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Name of the file to write to, or - for stdout. </td></tr>
    <tr><td class="paramname">domain</td><td>observation domain </td></tr>
    <tr><td class="paramname">export_meta</td><td>Export Template/IE Metadata </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fBuf_t a new writer, or a reused writer, for writing on the given open file. NULL on failure. </dd></dl>

</div>
</div>
<a id="a3670cb9472bebff1a4c14aafc8edfae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3670cb9472bebff1a4c14aafc8edfae5">&#9670;&nbsp;</a></span>yfWriterForFP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fBuf_t * yfWriterForFP </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>export_meta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an IPFIX message buffer for writing YAF flows to an open file pointer. </p>
<p >Sets the observation domain of the buffer to the given value. Note that this is intended for use with Airframe MIO based applications; non-MIO applications writing YAF IPFIX files should use yfWriterForFile instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>File pointer to open file to write to. </td></tr>
    <tr><td class="paramname">domain</td><td>observation domain </td></tr>
    <tr><td class="paramname">export_meta</td><td>Export Template/IE Metadata </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fBuf_t a new writer, or a reused writer, for writing on the given open file. NULL on failure. </dd></dl>

</div>
</div>
<a id="a2afc51621f94454beffc7862136ebc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afc51621f94454beffc7862136ebc73">&#9670;&nbsp;</a></span>yfWriterForSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fBuf_t * yfWriterForSpec </td>
          <td>(</td>
          <td class="paramtype">fbConnSpec_t *&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>export_meta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an IPFIX message buffer for writing YAF flows to a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>fixbuf connection specifier for remote end of socket. </td></tr>
    <tr><td class="paramname">domain</td><td>observation domain </td></tr>
    <tr><td class="paramname">export_meta</td><td>Export Template/IE Metadata </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new writer for export to the given address. </dd></dl>

</div>
</div>
<a id="aad688e7ab8e1c8a7c221db81b8b4ab9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad688e7ab8e1c8a7c221db81b8b4ab9b">&#9670;&nbsp;</a></span>yfWriteStatsFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfWriteStatsFlow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>yfContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pcap_drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GTimer *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a statistics options data record to an IPFIX Message buffer. </p>
<p >To turn off stats output - use &ndash;nostats. Sets the internal template to the stats option template, builds the record, and sends it - then sets the internal template back to the full flow record.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yfContext</td><td>Context pointer for the yaf state, used to get the fbuf pointer. </td></tr>
    <tr><td class="paramname">pcap_drop</td><td>Number of packets dropped reported by libpcap </td></tr>
    <tr><td class="paramname">timer</td><td>Pointer to yafstats GTimer </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a791a57ef2c8c5e66afa9ca3b9ceaa298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791a57ef2c8c5e66afa9ca3b9ceaa298">&#9670;&nbsp;</a></span>yfWriteTombstoneFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean yfWriteTombstoneFlow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>yfContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a tombstone options data record to an IPFIX Message buffer. </p>
<p >Sets the internal template to the tombstone option template, builds the record, and sends it - then sets the internal template back to the full flow record.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yfContext</td><td>Context pointer for the yaf state, used to get the fbuf pointer. </td></tr>
    <tr><td class="paramname">err</td><td>an error description; required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</body>
</html>
